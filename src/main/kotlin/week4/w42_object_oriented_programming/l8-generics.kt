package week4.w42_object_oriented_programming

/*
    Generic interfaces and classes
Как и в Java, вы можете определить интерфейс или класс с помощью универсального параметра. Затем, когда вы используете этот класс,
вы подставляете конкретный тип вместо параметра. Здесь мы определяем функции, которые работают отдельно со списком целых чисел или списком строк.

interface List<E> {
    fun get(index: Int): E
}
 */

fun foo(ints: List<Int>) {}

fun bar(strings: List<String>) {}

/*
    Generic functions
Если ваша функция должна работать со всеми универсальными типами, а не с определенным типом, таким как список целых чисел, вы можете сделать саму функцию универсальной.
Вы определяете параметр типа для функции и пытаетесь использовать этот параметр типа в объявлении функции в теле функции.
 */
//fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T> {
//    val destination = ArrayList<T>()
//    for (element in this) {
//        if (predicate(element)) destination.add(element)
//    }
//    return destination
//}


/*
Вы можете вызывать общую функцию для разных типов. Когда вы вызываете функцию фильтра, список T может стать списком фильтров строк или чем-то еще.
Параметр универсального типа T принимает разные значения. Обратите внимание, что мы не знаем, допускает ли T значение NULL или нет.
 */
//fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>
//    fun use1(ints: List<Int>) {
//        ints.filter { it > 0 }
//    }
//
//    fun use2(strings: List<String>) {
//        strings.filter { it.isNotEmpty() }
//    }


/*
Он может стать либо не допускающим значение NULL, либо типом, допускающим значение NULL. Вы можете вызвать фильтр в списке допускающих значение null или в списке строк,
допускающих значение null. Типы, допускающие значение NULL, подходят в качестве универсальных аргументов.
 */
//    fun use3(ints: List<Int?>) {
//        ints.filter { it != null && it > 0 }
//    }
//
//    fun use4(strings: List<String?>) {
//        strings.filter { !it.isNullOrEmpty }
//    }


/*
    Nullable generic argument
Вы можете явно сделать общие параметры обнуляемыми. Затем замененный тип также становится обнуляемым. В результате первая или нулевая функция возвращает тип,
допускающий значение null. Что вы называете первым нулем в списке целых чисел, вы получаете недопустимое целое число. Если он вызывается для списка элементов,
допускающих значение NULL, то T является ячейкой, допускающей значение NULL, а T, допускающий значение NULL, остается просто целым числом, допускающим значение NULL.
 */
//fun <T> List<T>.firstOrNull(): T?

//fun main() {
//    val ints = listOf(1,2,3)
//    val i: Int? = ints.firstOrNull()                // 1
//
//    val j: Int? = listOf<Int>().firstOrNull()       // null
//
//    val k: Int? = listOf(null, 1).firstOrNull()     // null
//}


/*
    Non-nullable upper bound
Если вы хотите ограничить общий аргумент, чтобы он не допускал значения NULL, вы можете указать ненулевую верхнюю границу. Вы добавляете верхнюю границу сразу после объявления
параметра типа, используя тот же столбец, который помещает ключевое слово экстентов в Kotlin. Если вы попытаетесь вызвать функцию, ожидающую, что по крайней мере элементы,
не допускающие значение NULL, передадут список элементов, допускающих значение NULL, вы получите ошибку компилятора. Тип Nullable не является подтипом non-nullable any,
поэтому такая функция не может быть вызвана таким образом.

 */
fun <T : Any> foo1(list: List<T>) {
    for (element in list) {

    }
}
//    foo1(listOf(1, null))
//  Error


/*
    Существует полезная библиотечная функция, которая отфильтровывает все нули из списка. Он вызывается для списка элементов, допускающих значение NULL, и возвращает список
элементов, допускающих значение NULL. No-null любая верхняя граница подчеркивает, что возвращаемый список не содержит пустых значений.

fun <T : Any> List <T?>.filterNotNull(): List<T> {}
 */

//fun main() {
//    val llist: List<Int> = listOf(1,null).filterNotNull()
//}


/*
    Type parameter constraints. Ограничения параметра типа
Вы можете указать другую верхнюю границу. В этом случае вы можете передавать как целые, так и двойные числа, поскольку они оба являются номерами экстентов.
 */
fun <T : Number> oneHalf(value: T): Double {
    return value.toDouble() / 2.0
}

/*
    Nullable upper bound
Верхняя граница может принимать значение NULL. Здесь вы можете передать целое число, двойное число или ноль в качестве аргумента.
 */
fun <T : Number?> oneHalf(value: T): Double? {
    if (value == null) return null
    return value.toDouble() / 2.0
}

/*
    Comparable upper bound
Как и в Java, верхняя граница может содержать параметр типа, это стандартный способ определения функции, которая должна работать с сопоставимыми элементами.
 */
fun <T : Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}


/*
    Multiple constraints for a type parameter. Несколько ограничений для параметра типа
Чтобы определить несколько параметров прототипа ограничений верхней границы, используйте край синтаксиса where объявления функции. Здесь вы можете передать любой тип,
который распространяется на различные интерфейсы, последовательность террас и множество. Stringbuilder реализует как последовательность террас, так и надежность,
поэтому это допустимый аргумент для этой функции.
 */
fun <T> ensureTrailingPeriod(seq: T)
        where T : CharSequence, T : Appendable {
    if (!seq.endsWith('.')) {
        seq.append('.')
    }
}

fun main() {
    println(oneHalf(13))    // 6.5
    println(oneHalf(null))  // null
    println(max(1, 3))           // 3

    val helloWorld = StringBuilder("Hello, World")
    ensureTrailingPeriod(helloWorld)
    println(helloWorld)     // Hello, World.
}

/*
    Same JVM signature
Из-за ограничений платформы JVM вы не можете определить две функции с одной и той же сигнатурой JVM, сигнатурой со стертыми параметрами универсального типа.
Здесь мы попытались определить две функции расширения для элементов списка int типа double. Функции отличаются только значением аргумента универсального типа, int или double,
и этого недостаточно, компилятор Kotlin этого не позволяет.
 */
fun List<Int>.average(): Double{
    return 0.0
}

@JvmName("averageOfDouble")
fun List<Double>.average(): Double{
    return 0.0
}
/*
При применении перед объявлением пакета он изменяет имя файла под капотом, но также может изменять имя функции в байт-коде. В этом случае две функции теперь имеют разные
имена в байт-коде. Первая средняя, вторая средняя двойная. На уровне Jvm есть две разные функции, так что ошибки нет. Однако из Kotlin вы используете обе функции просто по
усредненному имени. . Компилятор Kotlin делает вывод, какую функцию вы хотите вызвать в каждом случае
 */
