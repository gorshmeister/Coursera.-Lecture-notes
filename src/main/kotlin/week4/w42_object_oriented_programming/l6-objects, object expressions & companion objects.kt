package week4.w42_object_oriented_programming

/*
    object = singleton

Object является синглтоном в Котлине. Синглтон — это класс, который имеет только один экземпляр. Используя ключевые слова object,
вы создаете класс и его экземпляр в одном месте.
*/
object KSingleton {
    fun foo() {}
}

/*
    object expression

Несмотря на то, что эта функция использует ключевое слово объекта, она представляет собой другую идею. Объектные выражения заменяют анонимные классы Java.
Представьте, что вам нужно реализовать интерфейс, переопределить пару методов в классе. Это будет единственное использование этого нового класса,
поэтому вам не нужно создавать для него именованный класс. В Java в этой ситуации вы создаете анонимный класс. В Kotlin вы используете объектные выражения.
Обратите внимание, что всякий раз, когда вы взаимодействуете, у него есть только один абстрактный метод, поэтому вы можете использовать лямбда.
Нет необходимости в объектном выражении. Но если вам нужно реализовать несколько методов, то вы будете использовать объектные выражения.

window.addMouseListener(
        object : MouseAdapter() {
            override fun mouseClocked(e: MouseEvent) {
                //  ...
            }

            override fun mouseEntered(e: MouseEvent) {
                // ...
            }
        }
    )
 */

/*
    companion object

    special object inside a class

Вы можете не только поместить внутренний или вложенный класс в другой класс, но и вложенный объект. Одним из примеров такого вложенного объекта является объект-компаньон.
Это вложенный объект внутри класса, но особый. Тот, к членам которого можно получить доступ по имени класса. В Kotlin нет статических методов, как в Java,
и объекты-компаньоны могут заменить их. Я хочу объяснить вам, почему у Kotlin есть сопутствующие объекты, но нет статических методов.
В этом случае сопутствующие объекты могут быть лучше.
 */

class Aa {
    companion object {
        fun foo() = 1
    }
}

//fun main() {
//    Aa.foo()
//}

/*
    companion object can implement an interface
Во-первых, сопутствующий объект может реализовывать интерфейс. Иногда нам не хватает этой функции в Java. Было бы неплохо,
если бы статический метод мог переопределить член интерфейса. Но для статики это невозможно. Теперь это возможно для объекта-компаньона.
Здесь сопутствующий объект реализует factory.
 */
interface Factory<T> {
    fun create(): T
}

class Af {
    private constructor()

    companion object : Factory<Af> {
        override fun create(): Af {
            return Af()
        }
    }
}

/*
Вы можете использовать экземпляр объекта-компаньона, к которому можно получить доступ просто по имени класса, в качестве экземпляра фабрики.
 */
fun <T> createNewInstance(factory: Factory<T>) {}

fun main() {
    createNewInstance(Af)
    Af.create()
}

/*
Еще одна вещь, которую вы можете сделать с сопутствующим объектом, это то, что вы можете прямо определить расширение.
Чтобы отличить расширение класса от расширения объекта-компаньона, вы используете суффикс компаньона.
После этого вы можете вызывать такую функцию расширения, как член объекта-компаньона, просто по имени класса.
 */

////business logic module
//class Person(val firstName: String, val lastName: String) {
//    companion object {}
//}
//
////client/server communication module
//fun Person.Companion.fromJSON(json: String): Person {
//    //
//}
//
//val p = Person.fromJSON(json)

/*
    No static keyword

В Kotlin нет статического ключевого слова. Статических членов нет. Вы можете спросить, где теперь вы должны определить статические члены? Ответ заключается в том,
что вы можете определить их на верхнем уровне внутри объектов и внутри сопутствующих объектов. По умолчанию стремитесь ставить все на высшем уровне.
Это первое место для размещения ваших ранее статических элементов в Java, но это не всегда возможно.

Declare "static" members:
at the top-level
inside objects
inside companion objects

Представьте, что ваш статический метод принимает экземпляр вашего класса и должен вызвать для него частный член или создать новый экземпляр с помощью частного конструктора.
 У вас нет доступа к закрытым членам из функций верхнего уровня вне класса. Вы можете вызывать его только из объекта или объекта-компаньона внутри того же класса.
 */

class C {
    companion object {
        @JvmStatic fun foo() {}
        fun bar() {}
    }
}
 /*
 По умолчанию ваши функции, определенные в companion object или в object, не будут компилироваться в статические члены.
 Из Java вы не можете вызывать их как статические члены. Но если вам это нужно, вы можете добавить аннотацию JvmStatic

 Обратите внимание, что из Java вы по-прежнему можете обращаться к членам объекта-компаньона как к членам специального экземпляра-компаньона.
 //C.Companion.foo();
 //C.Companion.bar();


 То же самое работает с объектами. Если вам нужно, чтобы член компилировался как статический и вызывался статическим из Java, добавьте аннотацию JvmStatic
 */

/*
    Nested object
Вы можете определить объект как вложенный в другой объект или другой класс.
 */
class D {
    object E
}