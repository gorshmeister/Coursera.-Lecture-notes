package week4.w42_object_oriented_programming

import week4.w42_object_oriented_programming.Color.*

/*
    enum class
Класс Enum представляет собой перечисление, как в Java.
Если вам нужен класс с фиксированным количеством значений, вы можете определить эти значения как константы перечисления.
Отличие от Java в том, что теперь enum — это не отдельный экземпляр, а модификатор перед ключевым словом class.
 */
enum class Color {
    BLUE, ORANGE, RED
}

/*
Наиболее распространенный способ работы с константами перечисления — использование выражений when.
Вы указываете действия, которые должны быть выполнены для разных констант перечисления.
 */
fun getDescription(color: Color) =
    when (color) {
        BLUE -> "cold"
        ORANGE -> "mild"
        RED -> "hot"
    }

/*
    enum class with properties
Внутри класса enum вы можете определить функции-члены и свойства.
Обратите внимание на синтаксис того, как мы инициализируем константы перечисления. Вы передаете разные значения в качестве аргументов конструктора внутри круглых скобок.
После этого вы вызываете методы и свойства непосредственно для констант перечисления.
 */
enum class Color1(
    val r: Int, val g: Int, val b: Int,
) {
    BLUE1(0, 0, 255), ORANGE1(255, 165, 0), RED1(255, 0, 0);

    fun rgb() = (r * 256 + g) * 256 + b
}
//fun main() {
//    println(BLUE1.r)
//    println(BLUE1.rgb())
//}

/*
    data modifier

    Copying the instance
Модификатор данных имеет методы equals, hashCode, to-string и copy.
Вы можете вызвать метод копирования, чтобы скопировать экземпляр класса данных и указать только те аргументы, которые должны быть изменены.
Остальные значения остаются прежними. Или вы можете передать все аргументы и только явно скопировать ссылку.
 */
data class Contact(val name: String, val address: String)
//fun main() {
//    val contact = Contact("Pasha", "SPB")
//    val contactCopy = contact.copy(address = "Saint-Petersburg")
//    println(contact)
//    println(contactCopy)
//}

/*
    Equals & reference equality
В Java все знают, что нужно вызывать метод equals вместо двойного знака равенства.
В противном случае вы получите ссылочное равенство вместо сравнения содержимого в случае переопределения equals. В Котлине это уже не так.
По умолчанию, когда вы используете двойной знак равенства, он становится equals под капотом. Если ваш класс переопределяет equals, он будет осмысленно сравнивать элементы.
Если по какой-то причине вам все еще нужно ссылочное равенство, вы можете использовать тройной знак равенства.
 */
//fun main() {
//    val set1 = setOf(1,2,3)
//    val set2 = setOf(1,2,3)
//
//    println(set1 == set2)   // true     (calls equals)
//    println(set1 === set2)  // false    (checks reference equality)
//}

/*
  Для data class генерируются правильные методы equals и hashCode.
Теперь сравним элементы по их содержанию. Для заимствованного класса данных здесь мы снова вызываем equals под капотом,
но теперь equals сравнивает содержимое, так что в результате мы получаем true.
 */
//fun main() {
//    val contact1 = Contact("Pasha", "SPB")
//    val contact2 = Contact("Pasha", "SPB")
//    println(contact1 == contact2)   // true (для data class == сравнивает содержимое, для обычного class - ссылки)
//}

/*
    Properties in primary constructor. Свойства в основном конструкторе
Обратите внимание, что компилятор использует свойства, определенные внутри основного конструктора, только для автоматически сгенерированных функций,
таких как to-string, equals и hashCode. Чтобы исключить свойство из сгенерированных реализаций, объявите его внутри тела класса, как свойство 1nickname в этом примере.
Тогда он не будет включен в строковое представление и его значение не будет использоваться для сравнения экземпляров.
 */
data class User(val email: String) {
    var nickname: String? = null
}

fun main() {
    val user1 = User("biba@gmail.com")
    user1.nickname = "bibis"

    val user2 = User("biba@gmail.com")
    user2.nickname = "Onotole"

    println(user1 == user2) //  true
//Здесь первый пользователь равен этому второму, несмотря на то, что у них разные значения свойства псевдонима,
// потому что значения в электронной почте сравниваются по умолчанию.
}

