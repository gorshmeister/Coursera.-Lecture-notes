package week4.w42_object_oriented_programming

/*
    Default constructor
Конструктор — это специальная функция, используемая для инициализации вновь созданного объекта.
Мы не используем новое ключевое слово в Котлине. Вы вызываете конструктор как обычную функцию.
Вы можете отличить вызов конструктора от вызова функции благодаря соглашению.
Имя класса начинается с заглавной буквы, и вы вызываете конструктор по имени класса, но имя функции начинается со строчной буквы.
Если вы не определяете конструкторы в классе, компилятор Kotlin по умолчанию создает один без параметров.
Вот почему вы можете создать экземпляр класса A здесь. Конструктор по умолчанию был сгенерирован автоматически.
    class A
    val a = A()
 */

/*  Concise primary constructor. Краткий первичный конструктор
    Часто вам нужны некоторые аргументы для создания нового экземпляра класса. Затем вы определяете конструкторы явно.
Главный конструктор называется первичным конструктором. У него очень лаконичный синтаксис, когда это тривиально.
Он только инициализирует свойства его прошлыми значениями.
Здесь у нас есть два свойства, которые я инициализировал значениями из конструкции.
 */
class Person(val name: String, val age: Int)


/*
    Full primary constructor syntax
 После имени класса в скобках указываются параметры конструктора.
 Вы можете поместить сложную логику инициализации в раздел init, который представляет тело конструктора.
 */
class Person1(name: String) {
    init {

    }
}

/*
По умолчанию вы определяете свойства внутри тела класса между фигурными скобками.
Здесь вы можете увидеть полный синтаксис при инициализации свойства с соответствующим параметром конструктора в теле конструктора.
 */
class Person2(name: String) {
    val name: String

    init {
        this.name = name
    }
}

/*
    val/var on a parameter creates a property
Когда вы ставите val или var перед параметром, это автоматически создает свойство.
Без val или var это параметр конструктора.

Person(без возраста) == Person2 смотри выше
 */

/*
    Changing visibility of a constructor
При необходимости вы можете изменить видимость конструктора.
В этом случае вам нужно явно использовать ключевое слово конструктора и поместить его между именем класса и скобками.
Вы можете добавить Private или Internal видимости, что вам нужно.
 */
class InternalComponent
internal constructor(name: String)

/*
    Secondary constructor
Вы можете определить вторичные конструкторы.
Если аргументы по умолчанию вам не подходят и вам нужен другой список аргументов, вы можете это сделать.
Каждый вторичный конструктор должен вызывать другой вторичный или первичный конструктор. Вы вызываете другой конструктор,
используя ключевые слова this. Обратите внимание, что если присутствует первичный или вторичный конструктор,
конструктор по умолчанию без аргументов не создается, а затем автоматически генерируется только в том случае,
если вы не определяете никаких других конструкторов.
 */
class Rectangle(val height: Int, val width: Int) {
    constructor(side: Int) : this(side, side)

}
//fun main() {
//    val r = Rectangle(10)
//    println(r.width)
//    println(r.height)
//}


/*
    Different syntax for inheritance
В Kotlin синтаксис для выражения наследования немного отличается от Java.
Вы используете двоеточие для замены ключевых слов в скобках как Extends, так и Implements при расширении класса,
обозначаемого вызовом конструктора.
 */
interface Base
class BaseImpl : Base

open class Parent
class Child : Parent()

/*
    Calling a constructor of the parent class
Если вам нужно передать какие-либо аргументы для инициализации суперкласса, вы помещаете их в эти круглые скобки.
Используйте ключевое слово super для вызова конструктора родительского класса из вторичного конструктора.
 */
open class Parent1(val name: String)
class Child1(name: String) : Parent1(name)

open class Parent2(val name: String)
class Child2: Parent2 {
    constructor(name: String, param: Int) : super(name)
}

fun main() {
}

