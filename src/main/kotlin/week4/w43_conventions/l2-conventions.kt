package week4.w43_conventions

import java.awt.Point
import java.math.BigInteger

/*
    Comparisons

В Kotlin вы можете сравнивать строки, используя этот приятный синтаксис. Не только эти строки, но и любые классы, определяющие сравнительный метод. Под капотом все операторы
сравнения компилируются с использованием сравнительного метода сравнения. Обратите внимание: если ваш класс реализует comparable интерфейс, вы можете автоматически
сравнивать его экземпляры, используя этот удобный синтаксис.
    "abc" < "def"
a >= b  -> a.compareTo(b) >= 0
 */

/*
    Equality check
Проверка равенства, как мы уже обсуждали, скомпилирована для вызова равенства под капотом. Он не только вызывает равенство, но и корректно обрабатывает нулевые значения.
Вам больше не нужно помнить, что перед проверкой на равенство нужно проверять переменную на ненулевое значение.

s1 == s2    calls equals under the hood:    s1.equals(s2)

s1 == s2       // s1.equals(s2)
null == "abc" // false
null == null // true
 */

/*
    Accessing elements by index: []
Когда вы получаете доступ к элементам по индексу, это также работает по соглашению. Под капотом вызываются методы get и set.
https://i.imgur.com/2eR8quA.png

Вы можете определить функции оператора get и set как члены или расширения для ваших собственных пользовательских классов. Обратите внимание, что вы можете поместить несколько
аргументов в квадратные скобки.
    board[1,2] = 'x'

class Board {}
operator fun Board.get(x: Int, y: Int): Char {}
operator fun Board.set(x: Int, y: Int, value: Char) {}
 */


/*
    The in convention
Когда вы проверяете, принадлежит ли элемент хотя бы карте или диапазону, под капотом contains вызов.
if (key in map) {}
if (el in list) {}

a in c  ->  c.contains(a)
 */

/*
    The rangeTo convention
Создание диапазона — еще одно соглашение. Всякий раз, когда вы используете синтаксис с двумя точками, вы фактически вызываете диапазон для работы вашей функции. Это означает,
что вы можете поддерживать один и тот же синтаксис для своих пользовательских классов.
if (s in "abc".."def") {}
for (i in 1..2) {}

val oneTo100: IntRange = 1..100
for (i in oneTo100)

start..end  ->  start.rangeTo(end)
 */

/*
    The iterator convention
Итерация цикла for также проходит через соглашение. В Kotlin вы можете перебирать строку. Я уже говорил вам, что строка Kotlin под капотом — это строка обычной длины Java.
Но строка длины Java не реализует итерируемый интерфейс. Итак, в Java вы не можете перебирать его. В Kotlin это возможно, потому что мы можем определить этот оператор
итератора как функцию расширения.
operator fun CharSequence.iterator(): CharIterator {}

for (c in "abc")
 */

/*
    Destructuring declarations
Объявления деструктуризации позволяют вам определять несколько переменных одновременно, присваивая одно выражение и автоматически деструктурируя его. Мы уже видели в курсе
 примеры синтаксиса объявления деструктуризации. Здесь в обоих случаях мы инициализируем две переменные одной парой. Компоненты пары автоматически назначаются первой и второй
  переменным.
val (first, second) = pair
https://i.imgur.com/NYuBgl8.png
 */

/*
Вам редко нужно добавлять операторские функции компонента вручную. Вы можете использовать любой класс данных в качестве правой части для объявлений деструктурирования,
так как для него автоматически генерируются необходимые функции компонента.
Методы компонентов — это оставшиеся методы, которые мы еще не обсудили, которые автоматически генерируются для классов данных. Задается порядок деструктурированных
переменных. Для класса данных компилятор просто следует порядку аргументов конструктора val. Обратите внимание, что вы можете опустить одну из новых переменных,
если не собираетесь ее использовать. Поставьте подчеркивание вместо его имени. Затем он участвует в деструктуризации, но переменная не создается.
  https://i.imgur.com/vvkR2Vn.png
 */

/*
    compareTo convention
Представьте, что для вашего алгоритма вам нужен особый способ сравнения, например, точек. Если Point реализует Comparable, то логика сравнения становится доступной везде.
Но если вы определяете расширение CompareTo, вы можете сделать его приватным или внутренним в вашем модуле, чтобы оно было доступно только для целей вашего алгоритма.
Тогда синтаксис оператора не виден для других частей вашего приложения, использующих тот же класс точек. Существует мощный способ ограничить видимость,
но сделать вещи достаточно удобными для некоторых мелких деталей.

private operator fun Point.compareTo(other: Point): Int {}

    the operator syntax works only when the private operator is visible
 */

/*
    Extensions can be added
Если метод называется по-другому, вы всегда можете добавить расширение и использовать его из Kotlin более удобным способом.
https://i.imgur.com/1JsMBB1.png
 */
operator fun BigInteger.plus(other: BigInteger) = this.add(other)

fun main() {

    val m = mutableMapOf('a' to 1, 'b' to null, 'c' to 3)
    m['b'] = m['b']?.plus(1) ?: 333
    println(m)
}