package week5.w52_sequence

import java.math.BigInteger
import kotlin.random.Random

/*
    Generating a sequence
Если вам нужно создать последовательность с нуля, например, вы определяете способ получения каждого нового элемента из сети, вы можете использовать функцию generateSequence.
Здесь он генерирует последовательность случайных чисел. Когда лямбда, вычисляющая каждый новый элемент, возвращает нет, последовательность завершается. Обратите внимание,
как мы использовали функцию takeIf для проверки предиката и возврата null, если этот предикат не выполняется.
 */

val seq = generateSequence {
    Random.nextInt(5).takeIf { it > 0 }
}
//fun main() {
//    println(seq.toList())
//}


/*
    Reading input
    Функция generateSequence может быть полезна, когда вам нужно прочитать ввод и остановиться при вводе определенной строки.
 */
//fun main() {
//    val input = generateSequence {
//        readLine().takeIf { it != "exit" }
//    }
//    println(input.toList())
//}

/*
    Generating an infinite sequence
Вы можете использовать другую перегруженную версию функции generateSequence. Он использует первый элемент для того, чтобы вычислить каждый новый элемент на основе предыдущего.
В этом случае мы генерируем бесконечную последовательность целых чисел. Обратите внимание, что поскольку эта последовательность вычисляется лениво, она может быть бесконечной.
Ничего не происходит, пока вы явно не попросите об этом. В этом случае мы запрашиваем только первые пять элементов, и они возвращаются. Обратите внимание,
что поскольку под капотом скрыты те же целые типы, что и в Java, у вас все равно будет целочисленное переполнение. Чтобы предотвратить это, вы можете использовать большие
целые числа.
 */
//fun main() {
//    val numbers = generateSequence(0) { it + 1 }
//    println(numbers.take(5).toList())
//
//    //to prevent integer overflow
//    val bigNumbers = generateSequence(BigInteger.ZERO) {
//        it + BigInteger.ONE
//    }
//    println(bigNumbers.take(5).toList())
//}


/*
    Yield
Yield позволяет вам получать элементы произвольным образом. Общие функции последовательности, которые мы видели ранее, довольно ограничены.
Лямбда, генерирующая элемент последовательности, должна быть основана либо на внешних источниках, либо на основе предыдущего элемента, но вы не можете это настроить.
С yield вы можете генерировать любые элементы в любом удобном порядке. Вам нужно использовать yield внутри лямбда-аргумента функции последовательности.
 */
//fun main() {
//    val numbers = sequence {
//        var x = 0
//        while (true) {
//            yield(x++)
//        }
//    }
//    println(numbers.take(5).toList())   // [0, 1, 2, 3, 4]
//}

/*
Yield работает лениво. Он будет вызываться в ленивой манере только при необходимости. Если что-то не требуется, оно не будет вычислено. Вы можете получить любые элементы, которые вы хотите. Основная идея заключается в том, что вы можете выполнять любые промежуточные вычисления между этими выходами.
 */

fun main() {
    fun mySequence() = sequence {
        println("yield one element")
        yield(1)
        println("yield a range")
        yieldAll(3..5)
        println("yield a list")
        yieldAll(listOf(7, 9))
    }

    println(mySequence()
        .map { it * it }
        .filter { it > 10 }
        .first())
}

/*
Сначала мы используем первый элемент, вызывая yield one. Но затем мы отфильтровываем его после сопоставления, потому что он не удовлетворяет нашему предикату.
Только после этого мы используем диапазон элементов три, четыре и пять, один за другим. Первый элемент три не удовлетворяет предикату. Затем у нас есть следующий элемент
четыре, который удовлетворяет предикату. Поскольку первой дроби нужен только один элемент, она просто возвращает ответ, 16 становится ответом, и вызываются только операторы
first yield. Мы уже нашли ответ, а это значит, что нам вообще не нужно вызывать последнюю часть. Результат уже есть. Это иллюстрирует ленивый способ построения
последовательности с использованием yield. Всякий раз, когда вам нужна некоторая пользовательская логика для построения последовательности, вы можете использовать yield.
https://i.imgur.com/IJ6mO3E.png
*/