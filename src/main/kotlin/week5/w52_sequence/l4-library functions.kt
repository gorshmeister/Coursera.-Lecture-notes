package week5.w52_sequence

class Person(val name: String, val age: Int)

/*
1)
    В этом случае count сделает свое дело. Это то же самое, что сначала отфильтровать коллекцию, а затем получить ее размер. Очевидно, что для одного вызова функции не
создаются дополнительные промежуточные коллекции. Для простых случаев вам не нужно создавать всю церемонию последовательностей или потоков, вы просто вызываете одну функцию.
Преимущество коллекций и последовательностей Kotlin по сравнению с потоками Java. Простой код не требует церемоний и выглядит так же просто, как и есть.

    people.filter { it.age < 21 }.size
                ->
    people.count { it.age < 21 }

2)
    В Kotlin есть удобная функция sortedByDescending, которая сортирует набор последовательности по заданному ключу в порядке убывания.

    people.groupBy { it.age }.reverse
                ->
    people.sortedByDescending { it.age }

3)
    Это функция mapNotNull. Обратите внимание, что mapNotNull выполняет те же две операции за один раз. Так что это лучше, чем два отдельных вызова. Сначала карта,
затем фильтр notNull. Когда вы впервые натыкаетесь на это имя функции, вы можете прочитать его двумя способами. Это либо сначала фильтруют элементы NotNull,
а затем сопоставляются только те, которые не равны нулю. Или, наоборот, сначала сопоставьте элементы, а затем отфильтруйте результат NotNull. Как видно из этого примера,
mapNotNull использует второй сценарий. Это точная замена map плюс вызов filterNotNull для результата.

    people.
        map { person ->
            person.takeIf { it.isPublicProfile }?.name
        }
        .filterNotNull()
                ->
    people.mapNotNull { person ->
        person.takeIf { it.isPublicProfile }?.name
    }
https://i.imgur.com/pMc5KJr.png

4)
    Следующий вопрос касается другого шаблона, когда вам нужно изменить элементы карты, хранящиеся по данному ключу. Если элемента нет, необходимо его инициализировать.
Здесь мы заполняем карту от возраста ключа int до списка людей и инициализируем ее для неанализируемого возраста во вновь созданном изменяемом списке.
Если человек определенного возраста, он добавляется в соответствующий список.
 */
/*
fun main() {
    val people = mutableListOf<Person>()
    val map = mutableMapOf<Int, MutableList<Person>>()
    for (person in people) {
        if (person.age !in map) {
            map[person.age] = mutableListOf()
        }
        val group = map.getValue(person.age)
        group += person
    }
//          ->
    for (person in people) {
        val group1 = map.getOrPut(person.age) { mutableListOf() }
        group1 += person
    }
}
*/
/*
Есть удобная функция getOrPut, которая позволяет либо добраться до значения по заданному ключу, либо поставить значение по умолчанию, если такого ключа нет. Обратите внимание,
что вторым аргументом функции getOPut является Lambda, а тело Lambda вызывается только при необходимости. Здесь новые экземпляры изменяемого списка будут создаваться только в
том случае, если их нужно добавить на карту. Если ключ возраста уже существует, экземпляр списка не создается. Функция getOrPut является встроенной, поэтому использование
Lambda не снижает производительность.


5)
    Следующий вопрос — как заменить весь этот код одним вызовом. Обратите внимание, что результат будет немного отличаться, потому что это будет доступная только для карта
записи вниз по списку.
*/
/*
fun main() {
    val people = mutableListOf<Person>()
    val map = mutableMapOf<Int, MutableList<Person>>()
    for (person in people) {
        if (person.age !in map) {
            map[person.age] = mutableListOf()
        }
        val group = map.getValue(person.age)
        group += person
    }
//              ->
    people.groupBy { it.age }
}*/
/*
Он делает то же самое, что и код выше. Он группирует элементы по заданному ключу и возвращает карту из ключа в соответствующую группу.

6)
    Следующий вопрос касается аналога функции groupBy для последовательностей. Знаете ли вы, как выполнять группировку лениво, например, для других операций или
 последовательностей, таких как фильтрация и сопоставление, без немедленного возврата результата?

 */
/*
fun main() {
    val people = mutableListOf<Person>()
    people
        .asSequence()
        .groupBy { it.age }
        .mapValues { (_, group) -> group.size }
//                  ->
    people
        .asSequence()
        .groupingBy { it.age }
        .eachCount()
}*/
/*
Вы можете использовать groupBy как для коллекций, так и для последовательностей. Он сразу строит карту из указанного ключа в группу элементов, имеющих этот ключ.
В этом примере мы затем подсчитываем размер каждой группы и в результате получаем карту от возраста до размера группы.
https://i.imgur.com/qpW248d.png

Однако иногда вы можете захотеть выполнить группировку лениво, чтобы фактический результат или другую необходимую информацию, основанную на группировке, можно было позже
получить по запросу. GroupingBy, как и другие ленивые операции с последовательностями, возвращает объект, в котором хранятся выполняемые операции, а не сама результирующая
карта. Объект группировки хранит исходную последовательность и ключ группировки, чтобы фактическая группировка могла быть выполнена, когда нужен результат.
EachCount — это функция, которую можно вызвать для такого объекта группировки, чтобы получить размер каждой группы. В результате у нас та же карта от возраста до размера
группы, что и раньше.
https://i.imgur.com/l3ZEYlX.png
*/
