package week5.w52_sequence

import week5.w51_inline_functions.filter

/*
    Collections vs Sequences
    Давайте подробно обсудим разницу между нетерпеливым и ленивым вычислением. Когда вы вызываете связанные операции над коллекциями, каждая операция создает новую коллекцию
в качестве промежуточного результата. Он вычисляет результат нетерпеливым способом. Вы всегда можете наблюдать за результатом вплоть до промежуточного этапа.

    Когда вы используете последовательности и ленивые вычисления, ничего не происходит, пока не понадобится результат. Все преобразования для первого элемента выполняются
только при вызове терминальной операции, требующей предыдущих результатов. В этом примере с последовательностями и ленивым вычислением мы выполняем все преобразования для
первых двух элементов, а затем find, уже находит их ответ и возвращает его. Это означает, что нам не нужно выполнять никаких операций для остальных элементов.
Нам не нужно их преобразовывать, потому что мы уже нашли их ответ, поэтому результат не нужен. Это иллюстрирует ленивость операции. Мы ничего не делаем, если в этом нет
необходимости. Если мы уже нашли результат и остались какие-то операции, то мы их не выполняем. Нетерпеливая оценка всегда выполняет все операции для всех элементов.
В этом разница.
https://i.imgur.com/Ppt7HuL.png
 */
val list1 = listOf(1,2,3,4)
val result = list1
    .asSequence()
    .map { it * it }
    .find { it > 3 }    // 4


/*
    Horizontal evaluation vs Vertical evaluation
Иногда термины «горизонтальная» и «вертикальная» оценки используются для описания одной и той же идеи. При горизонтальной оценке вы применяете операции к элементам
горизонтально. Сначала вы выполняете все операции над элементами первой коллекции, затем выполняете операции над элементами после первых преобразований и так далее.

При вертикальном вычислении, когда запрашивается результат, вы сначала обрабатываете первый элемент и все цепные операции для него, затем вы применяете все цепные операции
для второго элемента и так далее, пока не будет найден результат.
https://i.imgur.com/90XLcDx.png
 */

fun main() {
    fun m(i: Int): Int {
        print("m$i")
        return i
    }

    fun f(i: Int): Boolean {
        print("f$i")
        return i % 2 == 0
    }

    val listik = listOf(1, 2, 3, 4)
//    listik.map(::m).filter(::f)
    listik.asSequence().map(::m).filter(::f).toList()   // m1 f1 m2 f2 m3 f3 m4 f4
    listik.asSequence().filter(::f).map(::m).toList()   // f1 f2 m2 f3 f4 m4
}

/*
    Order of operations is important
Обратите внимание, что при работе с последовательностями может быть важен порядок операций. Иногда вы можете применять преобразования в другом порядке. Например,
если мы сначала вызовем карту, а затем фильтр, то карта будет применена ко всем элементам. Однако если мы их переключим, эта карта будет применяться только к элементам,
которые не были отфильтрованы. Не всегда возможно изменить порядок операций. Но если это возможно, это может изменить количество результирующих операций, которые будут
выполнены.
 */