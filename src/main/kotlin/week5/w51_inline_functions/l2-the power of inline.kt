package week5.w51_inline_functions

import week4.w42_object_oriented_programming.max
import java.util.concurrent.locks.Lock
import kotlin.concurrent.withLock

/*
    inline function
Встраивание функции означает, что компилятор подставляет тело этой функции вместо ее вызова.
Если встроенная функция принимает лямбду в качестве аргумента и вызывает только эту лямбду внутри, то встраивание подставит тело этой лямбды вместо кода, вызывающего эту лямбду
 */

/*
    inlining of run
«run» — самый простой пример. Он только вызывает лямбду и больше ничего не делает. На уровне байт-кода при генерации кода для собственного кода компилятор вместо вызова run
и создания объекта, называемого лямбда, будет генерировать тело лямбда напрямую. В результате у нас нет накладных расходов на производительность или
создания анонимного класса и объекта для лямбды.
 */
val name = "Kotlin"
//fun main() {
//    run { println("Hi, $name") }
//}

/*
    inlining of takeUnless
Теперь давайте посмотрим на функцию takeUnless, которая делает что-то менее тривиальное. Он содержит некоторую логику с выражением if. Вместо того, чтобы вызывать последнюю
функцию takeUnless в байт-коде, компилятор выстраивает ее и подставляет ее тело. Вместо вызова лямбды он подставляет код тела лямбды. Здесь вы можете видеть, что вместо
создания объекта для лямбда у нас есть лямбда-код, записанный непосредственно в результирующем байт-коде. Конечно, компилятор накладывает некоторые ограничения на то,
что можно делать с лямбда-выражениями внутри встроенных функций. Вы все равно не можете сохранить лямбду, вы можете вызывать ее только напрямую. Затем можно сгенерировать
лямбда-код на месте. Все измеренные библиотечные функции просто несколько раз вызывали лямбду нулем, но не пытайтесь отложить вызов.
 */
fun foo(number: Int) {
    val result = number.takeUnless { it > 10 }
    println(result)
}
// bytecode
//  val result = if (!(number > 10)) number else null

//fun main() {
//    foo(100)    // null
//}

/*
    inlining synchronized
Когда синхронизированная функция помечена как встроенная, это означает, что она не приводит к снижению производительности. В полученном байткоде подставляется все тело функции
вместо одного вызова. Компилятор генерирует тело синхронизированной функции, заменяя использование параметров фактическими переданными аргументами. Всякий раз,
когда компилятор находит вызов лямбда-выражения, он вместо этого генерирует тело лямбда-выражения.
https://i.imgur.com/XOVjPDP.png
 */

/*
    withLock function
Обратите внимание, что всякий раз, когда вам нужно что-то сделать с блокировками вместо синхронизации в kotlin, вы можете использовать withLock. Он делает то же самое,
но определяется как расширение. Вы вызываете withLock для объекта блокировки.
 */
//val l: Lock =
//    l.withLock {
//        //access the recource protected by this lock
//    }


/*
    Resource management: use function
Управление ресурсами
В Java у нас есть синтаксис попытки с ресурсами. Выражение 'try' может правильно закрыть ваш источник, если возникло исключение. Он правильно распространяет начальное
исключение, если при закрытии ресурса возникает другое исключение. В Java это специальная конструкция языка. В Kotlin вся эта логика определяется внутри обычной библиотечной
функции. Эта библиотечная функция определена как встроенная. Таким образом, из-за лямбда-выражений нет накладных расходов на производительность. Функция «использовать»
содержит всю вышеупомянутую логику правильного закрытия ресурсов.
https://i.imgur.com/UyYU54m.png
 */




