package week5.w51_inline_functions

import week4.w41_properties.User

/*
    run function
Мы уже видели функцию run. На первый взгляд это похоже на встроенную языковую конструкцию, которая запускает блок кода и возвращает результат.
Но на самом деле это просто библиотечная функция, которая принимает лямбду в качестве аргумента.
 */
val foo = run {
    println("Calculating foo...")
    "foo"
}


/*
    let function
Еще одна полезная функция — let. Это можно использовать для работы с типами, допускающими значение NULL.
Часто бывают случаи, когда вы хотите передать что-то в качестве аргумента, только если оно не равно null. Например, здесь у нас
есть функция getEmail, которая возвращает адрес электронной почты, допускающий значение NULL. Мы хотим отправить электронное
письмо, только если оно не равно нулю. Если он нулевой, то мы ничего не делаем. Вы можете использовать явный тег if для
этого, но пусть дает вам альтернативу. Что вы можете сделать, так это использовать let, который вводит новое имя для
получателя. Затем вы можете получить доступ к получателю внутри лямбды по имени аргумента. Обратите внимание, что здесь мы
используем безопасный доступ. Это означает, что функция let вызывается только в том случае, если получатель не равен нулю.
Мы выполнили действие sendEmail, только если адрес электронной почты не нулевой. В качестве приемника можно использовать
все выражение. Вам больше не нужно вводить новую переменную, чтобы иметь возможность использовать ее с умом. По сути,
let сам вводит новую переменную. Его название происходит от функционального программирования, где let используется для
введения новой переменной. Kotlin — это не чистый функциональный язык, вы можете просто объявить переменную.  Однако
для таких случаев использования с обнуляемостью let действительно полезен.
 */
fun getEmail(): String? {
//    return null
    return "bibis@pisikakis"
}

fun sendToEmail(email: String?) {
    println("send to $email")
}

//fun main() {
////    val email = getEmail()
////    if (email != null) sendToEmail(email)
//
////    email?.let { e -> sendToEmail(email) }
//    getEmail()?.let { sendToEmail(it) }
//}

/*
Еще один пример для let с нулевым значением. Теперь это обнуляемость и сохранение типов. Помните, пример, когда у нас есть свойство, определенное в интерфейсе, это открытое
свойство, поэтому вы не можете «умно преобразовать» его. Компилятор не знает, как это можно написать в этих классах приложений. Для смарт-приведения необходимо скопировать
свойство в новую локальную переменную. «Let» дает вам альтернативу. Если свойство «сессионный пользователь» может быть приведено к «пользователю Facebook», мы выполняем над
ним действие. В противном случае ничего не происходит. Смысл двух фрагментов кода с явными if и let одинаков. Использование let — это просто еще один способ написать это.
Здесь мы используем save cast as со знаком вопроса для проверки правильности типа. Если приведение успешно, то результат не равен нулю. В этом случае то, что мы вызываем
«let» и «внутри let», наш лямбда-аргумент имеет требуемый ненулевой тип.
 */
interface Session {
    val user: User
}

//  fun analyzeUserSession(session: Session) {
//     val user = session.user
//     if (user is FacebookUser) {
//         println(user.accountId)
//     }
//  }

//  (session.user as? FacebookUser)?.let {
//     println(user.accountId)
//  }


/*
    take if Function
Возвращает получателя, если он удовлетворяет заданному предикату или возвращает null. Здесь результатом является значение самой переменной задачи, если ее статус «ИСПРАВЛЕНО»,
и ноль в противном случае. Или мы можем захотеть заменить отчество на null, если оно пустое, взять строку, если оно не пустое, делает именно это

    issue.takeIf { it.status == FIXED }
    person.patronymicName.takeIf { String::isNotEmpty }
 */
//fun main() {
//    val number = 42
//    println(number.takeIf { it > 10 })  // 42
//
//    val other = 2
//    println(other.takeIf { it > 10 })   // null
//}

/*
Функция takeIf чрезвычайно полезна внутри связанных вызовов. Представьте, что вам нужно продолжить список операций только в том случае, если выполняется предикат.
Вы можете вызвать этот предикат на основе результата предыдущего выражения в цепочке вызовов. Использование этого безопасного оператора после результата takeIf продолжает
вызывать, только если предикат удовлетворен. В противном случае у вас в результате будет null, и все остальные вызовы не будут вызываться за вас. Здесь некоторые открытые
проблемы будут напечатаны только в том случае, если «Список отфильтрованных открытых проблем» не пуст.
    issue.filter { it.status == OPEN }
        .takeIf (List<issue>::isNotEmpty)
        ?.let { println("There some open issues") }
 */


/*
    takeUnless function
Есть и наоборот, takeUnless, которая возвращает получателя, если предикат не выполняется.
    person.patronymicName.takeUnless(String?::isNullOrEmpty)
 */

/*
    repeat function
Он просто повторяет действие заданное количество раз. Это очень удобно, и вместо цикла for с индексами для простых сценариев можно использовать повтор.
Опять тот же шаблон. repeat не встроенный синтаксис, а функция, определенная в библиотеке.
 */
fun main() {
    repeat(10) {
        println("Zdarov")
    }
}
